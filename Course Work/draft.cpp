//---------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>

#define MAX_ROAD 25 //максимальная длина пути при случайной генерации
#define INFINIT 0xFFFFFFFF //"бесконечность"

//односвязный список с целочисленным полем данных
struct numlist
{
	unsigned int num;//номер города
	numlist * next;//указатель на следующий элемент списка
};
//вычисление длины списка
unsigned int length(numlist* root)
{
	numlist *p1 = root;
	unsigned int len = 0;
	while(p1)
	{
		p1 = p1->next;
		len++;
	}
	return len;
}
//найти элемент с данным значением
numlist * find(numlist*root,unsigned int num)
{
	if(!root)
		return NULL;
	else if(root->num==num)
		return root;
	else return find(root->next,num);//рекурсивный вызов
}
//добавить элемент в конец списка
void append(numlist*p,unsigned int num)
{
	if(!p)return;//неверные параметры
	if(p->next)append(p->next,num);//рекурсивный вызов
	else
	{//добавляем новый элемент
		p->next = new numlist;
		p->next->next = NULL;
		p->next->num = num;
	}
}
//вставить новый элемент в список после текущего(указнного)
void insert(numlist*p,unsigned int num)
{
	if(!p)return;//неверные параметры
	numlist *pn= p->next;//сохраняем указатель на следующий элемент
	//вставляем новый элемент
	p->next = new numlist;
	p->next->next = pn;//восстанавливаем указатель на следующий элемент
	p->next->num = num;
}
//уничтожить список
void destroy(numlist * root)
{
	if(!root)return;//неверные параметры
	if(root->next)destroy(root->next);//рекурсивный вызов (повлечёт уничтожение всех последующих элементов)
	//уничтожаем данный элемент
	root->next = NULL;
	delete root;
}

/*Функция нахождения кратчайшего пути между двумя городами,
заданного матрицей длин дорог.
используется алгоритм Дейкстра
Функция возвращает указатель на начало списка, содержащего путь,
если путь не найден, возвращается 0*/
numlist * find_short_path(
	unsigned int *mc,//матрица длин дорог
	unsigned int n,//количество городов
	unsigned int start,//начальный город пути (нумерация с 0)
	unsigned int finish//конечный город пути (нумерация с 0)
	)
{
	struct label//структура для хранения данных о метке
	{
		int is_const;//признак постоянства метки
		unsigned int value;//значение метки
	};

	label *lab = new label[n];//множество меток городов
	unsigned int p=start;//номер текущей рассматриваемой метки
	unsigned int nmin_lab;//номер минимальной метки (используется при превращении метки в постоянную)
	numlist * path = NULL;//список, содержащий путь (номера городов по порядку)
	
	//устанавливаем все метки городов в бесконечность и делаем их временными
	for(unsigned int i = 0;i<n;i++)
	{
		lab[i].value = INFINIT;//значение метки = бесконечность
		lab[i].is_const = 0;//признак временности метки
	}
	//устанавливаем метку начального города пути в 0 и делаем её постоянной;
	lab[start].value = 0;
	lab[start].is_const = 1;//постоянная метка

	for(unsigned int k =0;k<n;k++)
	{//итераций алгоритма не более, чем вершин (больше бессмысленно, т.к. все вершины получат постоянные метки или не будут достигнуты)
		//ОБНОВЛЕНИЕ МЕТОК
		for(i=0;i<n;i++)
		{
			if(//если
				(lab[i].is_const==0)&&//i-й город имеет временную метку
			    (mc[p*n+i]))//и есть дорога из p-го в i-й город
			{//то происходит пересчёт метки
				unsigned int new_value =  lab[p].value+mc[p*n+i];//новый путь до данного города
				if(new_value < lab[i].value)//если он короче известного на данный момент,
					lab[i].value = new_value;//то запомнить его
			}
		}
		//ПРЕВРАЩЕНИЕ МЕТКИ В ПОСТОЯННУЮ
		//1, поиск минимальной метки из временных
		nmin_lab = INFINIT; //несуществующий номер
		for(i=0;i<n;i++)
		{//цикл поиска города с минимальной временной меткой
			if(//если
				(lab[i].is_const==0)//i-й город имеет временную метку
				&&(lab[i].value!=INFINIT))// и её значение не равно бесконечности
			{//   (это город с временной меткой и небесконечным значением этой метки)
				if(nmin_lab==INFINIT)
				{//минимум ещё не найден (это первый встеченный город с подходящей меткой)
					nmin_lab = i;//запомнить номер города с минимальным значением временной метки на данный момент
				}
				else
				{//уже есть минимум - надо сравнить метку текущего города с текущим минимумом
					if(lab[i].value < lab[nmin_lab].value)
						nmin_lab = i;//это новый минимум (номер вершины с минимальным значением временной метки)
				}
			}
		}
		//2. пометить минимальную временную метку как постоянную
		if(nmin_lab!=INFINIT)
		{//если минимум найден
			lab[nmin_lab].is_const = 1;//устанавливаем постоянную метку
			p = nmin_lab;//передвигаем текущий указатель
			if(lab[finish].value==lab[nmin_lab].value)
				break;//дальше можно не искать, короче пути уже не будет
		}
		else
		{// нет минимума!!!
			break;//некуда больше двигаться, т.к. временные небесконечные метки кончились!
		}
		//ЕСЛИ ЭТО КОНЕЧНАЯ ВЕРШИНА, ТО ПУТЬ НАЙДЕН, ИНАЧЕ ИСКАТЬ ДАЛЕЕ
		if(p==finish)
			break;//путь пройден
		else
			continue;//продолжить
	}

	//проверяем: найден ли путь?
	if(lab[finish].value!=INFINIT)
	{//метка конечной вершины не бесконечная, значит какой-то путь найден
		//восстановление пути
		numlist *reversepath = new numlist;//путь в обратном направлении (только так позволяет восстановить его алгоритм)
		reversepath->next = NULL;
		reversepath->num = finish;//номер последней вершины
		p=finish;
		
		//сохраняем путь в список вершин (собираем с конца)
		while(p!=start)//пока в путь не добавлена начальная вершина
		{
			for(i=0;i<n;i++)
				if(mc[i*n+p])//если между i-й и р-й вершинами есть дуга
					if(lab[i].is_const)//и постоянная метка у i-й вершины установлена
						if((lab[i].value + mc[i*n+p]) == lab[p].value)//длина пути до p-й вершины равна сумме длины пути до i-й вершины и дуги между ними
						{//это вершина входит в путь
							p = i;//на одну вершину назад
							append(reversepath,i);//запоминаем найденную вершину в список пути
							break;//на проверку: не весь ли путь уже собрали
						}
		}
		//разворачиваем путь, чтобы вернуть пользователю в нормальном виде
		path = new numlist;
		path->next = NULL;
		path->num = start;//первая вершина пути
		numlist * tmp = reversepath;
		while(tmp->next)//пока есть следующий элемент в списке (т.е. вплоть до предпоследнего элемента, т.к. последний элемент уже занесён - это start)
		{
			insert(path,tmp->num);//вставляем очередную вершину (номер) после начальной (остальные сдвигаются!!!)
			tmp = tmp->next;//переход на вершину в обратном пути
		}
		destroy(reversepath);//освобождение занятых ресурсов
	}

	//освобождение памяти
	delete lab;
	//вовращаем указатель на список с найденным путем (0, если путь не найден)
	return path;
	
}


void main()
{
	unsigned int citynum;//количество городов
	unsigned int *roads;//система односторонних дорог в виде массива
	unsigned int start,finish;//номера начального и конечного городов пути
	unsigned int i,j;
	numlist * pbadlist=NULL;//указатель на начало списка "плохих" городов
	
	do
	{
	  printf("Input number of cities: ");//"введите количество городов"
	  scanf("%u",&citynum);//получение количества городов
	  fflush(stdin);//защита от ошибок ввода - очистка буфера стандартного потока ввода
	}while(!citynum);

	//выделение памяти под массив дорог
	roads = new unsigned[citynum*citynum];

	printf("(Press space to random fill road's system or any key to fill it manually)...\n");
	if(getch()==' ')//получаем код нажатой клавиши
	{//нажат пробел - заполнение случайным образом
		//эту строчку можно раскомментировать, чтобы при каждом запуске случайно генерировались разные значения
		//srand((unsigned int)time(0));
		for(i = 0; i<citynum;i++)
		{
			//заполняем остальные элементы
			for(j=0;j<citynum;j++)
			{
				roads[i*citynum+j] = 
					(((rand()%3)!=0)?/*это позволяет получать нули в каждом третьем случае (приблизительно)*/
					(rand()%MAX_ROAD):0);//генерация значения длины из заданного диапазона
			}
			//заполняем элемент главной диагонали нулем
			roads[i*citynum+i] = 0;//0 означает отсутствие дороги (в данном случае из города в самого себя - это бессмысленно в контексте данной задачи)
		}
	}else
	{//нажата другая клавиша - заполнение пользователем вручную
		printf("\n");
		for(i = 0; i<citynum;i++)
		{
			//заполняем остальные элементы попарно (матрица симметричная)
			for(j=0;j<citynum;j++)
			{
				if(i==j)
				{
					//заполняем элемент главной диагонали нулями
					roads[i*citynum+i] = 0;//0 означает отсутствие дороги
				}
				else
				{
					unsigned int n;
					//"введите длину дороги между городами i и j (0 если нет дороги)"
					printf("Enter length of road from %u to %u (0 - no road): ", i+1, j+1);
					scanf("%u",&n);
					fflush(stdin);
					roads[i*citynum+j] = n;
				}
			}
		}
	}
	//ВЫВЕДЕМ НА ЭКРАН МАТРИЦУ ДЛИН ДОРОГ
	//матрица: на пересечении i-й строки и j-го столбца находится длина дороги из i-го города в j-й
	//вывод заголовка
	printf("\n\tThe roads lengths matrix\n");//матрица длин дорог
	//вывод заголовков столбцов (номера городов в которые входят дороги)
	printf("    ");
	for(i=0;i<citynum;i++)printf("%3d ",i+1);
	printf("\n");
	//вывод верхней планки
	printf("  |");
	for(i=0;i<citynum*4+1;i++)printf("-");
	printf("|\n");
	//вывод строк матрицы
	for(i=0;i<citynum;i++)
	{
		//вывод номера города, из которго выходит дорога
		printf("%2d|",i+1);

		for(j=0;j<citynum;j++)
		{
			if(roads[i*citynum+j])
				printf("  %2d",roads[i*citynum+j]);
			else
				printf("    ");//ничего не выводить, если элемент равен 0 (дорога отсутствует)
		}
		printf(" |\n");
	}
	//вывод нижней планки
	printf("  |");
	for(i=0;i<citynum*4+1;i++)printf("-");
	printf("|\n\n"); 
//---------------------------------------------------------------------------
	/*К этому моменту система односторонних дорог задана в виде массива roads размером
	citynum*citynum. Элементом массива roads[i*citynum+j] является длина дороги,
	идущей из города i в город j. Если такой дороги нет, то элемент равен 0.
	*/
	/*
	Теперь надо определить начальный и конечный город искомого пути
	*/
//---------------------------------------------------------------------------
	//ПРИГЛАШЕНИЕ ВВЕСТИ НОМЕРА ГОРОДОВ, МЕЖДУ КОТОРЫМИ БУДЕТ ИСКАТЬСЯ ПУТЬ
	do{
		//"Введите номер начального города пути (город А)"
		printf("Enter the number of A city (start) (1 ... %u): ",citynum);
		scanf("%u",&start);
		fflush(stdin);
	}while((start==0)||(start>citynum));
	do{
		//"Введите номер конечного города пути (город В)"
		printf("Enter the number of B city (finish) (1 ... %u): ",citynum);
		scanf("%u",&finish);
		fflush(stdin);
	}while((finish==0)||(finish>citynum)||(finish==start));
	//учитываем, что нумерация при операциях с массивами идёт с нуля
	start--;
	finish--;
	

//---------------------------------------------------------------------------
	/*К этому моменту известны начало и конец пути*/
	/*
	Надо определиться с множеством "запрещенных" городов
	*/
//---------------------------------------------------------------------------
	do
	{
		unsigned int n;
		printf("Enter the number of bad city (except %u,%u",start+1,finish+1);
		if(length(pbadlist))
		{
			//вывод всех уже выбранных городов
			numlist *p = pbadlist;
			while(p)
			{
				printf(",%u",p->num+1);
				p = p->next;
			}
		}
		printf(") (enter 0 to abort):");
		scanf("%u",&n);
		fflush(stdin);
		if(!n)
			break;//конец списка плохих городов
		if(n>citynum)
			continue;//слишком большой номер
		n--;//нумерация д.б. с 0!
		//если не 0 и ещё не запрещён и не стартовый и не конечный город пути, то добавить в список плохих городов,
		if((!find(pbadlist,n))&&(n!=start)&&(n!=finish)){
			if(pbadlist)
				append(pbadlist,n);
			else
			{//создадим самый первый элемент списка
				pbadlist = new numlist;
				pbadlist->next = NULL;
				pbadlist->num = n;
			}
		}
		//если все города уже либо "плохие", либо являются началом/концом пути, то выход из цикла
		if(length(pbadlist)+2>=citynum)
			break;
	}while(1);
//---------------------------------------------------------------------------
	/*К этому моменту известен список "запрещенных" городов*/
//---------------------------------------------------------------------------
	/*зануляем столбцы и строки массива дорог, соответствующие "плохим" городам,
	  тем самым мы делаем их недоступными!*/
//---------------------------------------------------------------------------
	numlist * p = pbadlist;
	while(p)//перебор всех элементов списка, начиная в первого
	{
		//обнуление соответствующих строки и столбца массива дорог
		for(i=0;i<citynum;i++)
		{
			roads[i*citynum+p->num] = 0;//обнуление исходящих дорог
			roads[p->num*citynum+i] = 0;//обнуление входящих дорог (на самом деле этого уже достаточно, т.к. в город не попасть!)
		}
		p = p->next;//переход на следующий элемент списка
	}
//---------------------------------------------------------------------------
	/*К этому моменту в системе односторонних дорог остались только дороги,
	не входящие и не выходящие в/из "плохие(х)" городаов()*/
//---------------------------------------------------------------------------
	
	//поиск пути между городами по заданной матрице дорог
	p = find_short_path(roads,citynum,start,finish);
	if(p)
	{//путь найден
		printf("Shortest path:");
		unsigned int len = 0;
		numlist * tmp = p;
		while(tmp)
		{
			printf(" %u",tmp->num+1);//вывод номера очередного города пути
			if(tmp->next)//если в пути есть следующий город
				len += roads[tmp->num*citynum+tmp->next->num];//прибавляем длину дороги до него к длине пути
			tmp = tmp->next;//переход на следующий город пути
		}
		printf(". Length=%u\n",len);
		destroy(p);//освобождение ресурсов
	}
	else
	{//путь не найден
		printf("Path not found (not exist)!\n");
	}

	printf("Press any key to exit...");
	getch();
	//освобождение ресурсов
	delete roads;
	destroy(pbadlist);
}